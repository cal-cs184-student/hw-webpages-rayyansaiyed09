<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 2 Write-Up</h1>
		<div style="text-align: center;">Names: </div>

		<br>

		Link to webpage: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>

		<br>
		
		Link to GitHub repository: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Section I: Bezier Curves and Surfaces</h2>

		<h3>Part 1: Bezier curves with 1D de Casteljau subdivision</h3>
		Bezier curves can be generated using de Casteljau's algorithm. Given <i>n</i> control points and a parameter <i>t</i> whose value is between 0 and 1, this algorithm uses a recursive computation to generate a point on the Bezier curve. 

		Starting with <i>n</i> points, <i>n-1</i> points are generated on the lines that connect the original points. These new points are a distance between the original points that is proportional to the parameter <i>t</i>. Once those new points are calculated, the process repeats until a single point is reached. This is the point that is on the Bezier curve. The original points are called <i>control points</i>.

		In our implementation, we take the points from the input and first check how many there are. If there's 2 or more, then the algorithm is implemented using the parameter <i>t</i> defined in the 'BezierCurve' class. Once the new points have been calculated, they are added to the vector using <mark>push_back()</mark>.
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="part1_curve.png" width="400px"/>
				  <figcaption>6 control points.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part1_first_lerp.png" width="400px"/>
				  <figcaption>First interpolation step.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part1_second_lerp.png" width="400px"/>
				  <figcaption>Second interpolation step.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part1_third_lerp.png" width="400px"/>
				  <figcaption>Third interpolation step.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="part1_fourth_lerp.png" width="400px"/>
				  <figcaption>Fourth interpolation step.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part1_final_point.png" width="400px"/>
				  <figcaption>Final interpolation step - the red point lies on the curve.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part1_lerps_and_curves.png" width="400px"/>
				  <figcaption>Curve alongside interpolation steps.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="part1_controls_and_curve.png" width="400px"/>
				  <figcaption>Curve and control points without interpolation steps.</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h3>Part 2: Bezier surfaces with separable 1D de Casteljau</h3>
		In this part, we expanded on de Casteljau from Part 1 to create Bezier surfaces. There were three function to modify:<br></br> 
		<code> BezierPatch::evaluateStep </code>: Basically the same as part 1, this function was responsible for doing a lerp between every consecutive pair of \(n\) points, returning \(n - 1 \) new points. <br></br>
		<code> BezierPatch::evaluate1D </code>: This function calls <code>evaluateStep()</code> recursively to determine the final control point. Returns when input vector of points has size of 1.<br></br>
		<code> BezierPatch::evaluate </code>: This is responsible for parsing through the provided 2D array of points and invoking <code>evaluate1D()</code> on every row using the parameter u. This returns a new list of points which we can once again call <code>evaluateStep()</code> with parameter v to return us our final coordinate. <br></br>

		<figure>
			<img src="rendered_teapot.png" alt="Teapot" style="width:50%"/>
			<figcaption>Teapot image rendered with separable 1D de Casteljau</figcaption>
		</figure>

		<h2>Section II: Triangle Meshes and Half-Edge Data Structure</h2>

		<h3>Part 3: Area-weighted vertex normals</h3>

		We first iterated through all the adjacent triangles that the vertex (v0) is part of by doing <code>halfedge = halfedge->twin()->next()</code>. For each of these halfedges (triangles), we calculate the normal by finding the two connected vertices (v1, v2). Since we are guaranteed triangles (and no other polygon), we just need 2 more vertices. Using these vertices we then found the normal by calculating the cross product using vertex position: \( (v1 - v0) x (v2 - v0) \). We then sum up all the normals for each face and normalize this total normal. 

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="task3-teapot.png" width="400px"/>
				  <figcaption>Original teapot shading with no normalization. Sharp edges on surface makes triangles very apparent.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task3-normal.png" width="400px"/>
				  <figcaption>With Phong shading, surface of teapot is much smoother.</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h3>Part 4: Edge flip</h3>
		In our code, the first step we did was clearly define every mesh element (vertices, edges, halfedges, faces). once we had pointers to each of these, we then used the <code>HalfedgeMesh::setNeighbors()</code> to reassign the edges. Using vertices as described in the spec:
		<figure>
			<img src="edgeflip_diagram.png" alt="Teapot" style="width:75%"/>
		</figure>

		<table>
			<thead>
				<tr>
				<th>Half-edge</th>
				<th>Next</th>
				<th>Twin</th>
				<th>Vertex (Source)</th>
				<th>Edge</th>
				<th>Face</th>
				</tr>
			</thead>
			<tbody>
				<tr>
				<td><strong>h_bc</strong></td>
				<td>h_dc</td>
				<td>h_cb</td>
				<td>v_a</td>
				<td>e_bc</td>
				<td>f0</td>
				</tr>
				<tr>
				<td><strong>h_cb</strong></td>
				<td>h_ab</td>
				<td>h_bc</td>
				<td>v_d</td>
				<td>e_bc</td>
				<td>f1</td>
				</tr>
				<tr>
				<td><strong>h_ca</strong></td>
				<td>h_bc</td>
				<td>h_ca->twin()</td>
				<td>v_c</td>
				<td>h_ca->edge()</td>
				<td>f0</td>
				</tr>
				<tr>
				<td><strong>h_ab</strong></td>
				<td>h_bd</td>
				<td>h_ab->twin()</td>
				<td>v_a</td>
				<td>h_ab->edge()</td>
				<td>f1</td>
				</tr>
				<tr>
				<td><strong>h_bd</strong></td>
				<td>h_cb</td>
				<td>h_bd->twin()</td>
				<td>v_b</td>
				<td>h_bd->edge()</td>
				<td>f1</td>
				</tr>
				<tr>
				<td><strong>h_dc</strong></td>
				<td>h_ca</td>
				<td>h_dc->twin()</td>
				<td>v_d</td>
				<td>h_dc->edge()</td>
				<td>f0</td>
				</tr>
			</tbody>
		</table>

		It was also important to update the halfedge corresponding to each of the faces. Using these reassignments we were able to create the following:
		<figure>
			<img src="task4-teapot-zigzag.png" alt="Teapot" style="width:75%"/>
			<figcaption>Zigzag edges were created by flipping the edges of every other row.</figcaption>
		</figure>

		<h3>Part 5: Edge split</h3>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h3>Part 6: Loop subdivision for mesh upsampling</h3>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Section III: Potential Extra Credit - Art Competition: Model something Creative</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>