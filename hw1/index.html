<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: Rayyan Saiyed && Daniel Grover</div>

		<br>

		Link to webpage: <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>
		
		<br>

		Link to GitHub repository: <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.
		
		<h2>Task 1: Drawing Single-Color Triangles</h2>
		Our rasterizer takes the three points that define the triangle and uses them to create a bounding box by finding the minimum and maximum x and y values of the points. We then iterate through this bounding box and test if a point is inside or outside the triangle. We do this by seeing if the point is on the inside or outside of any of the sides of the triangle. If a point is on the inside of all three lines, it is inside the triangle. If a point passes this test, it is rounded to an integer value and draw using the fill_pixel function.

		This is not any worse than an algorithm that checks each sample within the boudning box of the triangle, because that is exactly what our algorithm does. 

		<figure>
			<img src="screenshot_2-11_15-34-8.png" alt="cubeman" style="width:50%"/>
			<figcaption>The new cubeman doing a jumping jack.</figcaption>
		</figure>
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		
		The main idea behind super sampling is to initially treat our frame buffer as if it has a higher pixel resolution than it really does (called the sample buffer). Therefore we did not have to change the rasterize triangle too much aside from the indexing logic into the sample buffer. More critically, when the sample buffer is written, we have to crash it down to the actual frame buffer size. We iterated through each of the frame buffer's pixels and for each pixel, we indexed all the sample_rate-number of samples in the sample_buffer. We then read the stored color and added it into a vector of colors. After reading all the super sampled pixels, we averaged the colors for each rgb value and stored that new Color in the frame buffer. Super sampling is very useful because it allows us to better approximate how much of a shape is actually in the pixel, rather than just testing if the center of the pixel is filled in or not. Pixels can now be partially on/off rather than completely on/off.
		<p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a column in that row. You might find this useful for framing and showing your result images in an organized fashion.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="task2/sample_rate1.png" width="400px"/>
				  <figcaption>1 sample / pixel - Basic shapes without sharp edges look decent, however edges are very sharp. One pixel is fully turned on, and the one next to it is completely off. Some pixels in between are even turned off since the triangle does not pass through the center of the pixel creating a jagged look.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task2/sample_rate4.png" width="400px"/>
				  <figcaption>4 samples / pixel - Already more improved, as gaps between pixels no longer exist (only at the very very corner pixel). Shades of color are introduced, slightly easing edges. Slghtly more pixels have a lower shade of color. This is coming from the pixels whose centers were originally not filled in, but there corners were.  </figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="task2/sample_rate9.png" width="400px"/>
				  <figcaption>9 samples / pixel - Visually continuous at sharp corners. Not much of a difference for basic shapes since the same percentage of pixels are being covered no matter the sampling rate (e.g. long edge of yellow triangle will have pixels who are 50% covered, whether sampled at 4, 9 etc.).</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task2/sample_rate16.png" width="400px"/>
				  <figcaption>16 samples / pixel - Appears nearly perfect from the larger perspective. Edges of pixel look very soft. Pixel inspector reveals many more pixels have at least some shade compared to no super sampling.  </figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h2>Task 3: Transforms</h2>
		The new cubeman was edited to look like he is mid-jumping jack, or doing a star jump. 
		<figure>
			<img src="screenshot_2-11_22-36-36.png" alt="cubeman" style="width:50%"/>
			<figcaption>The new cubeman doing a jumping jack.</figcaption>
		</figure>

		<h2>Task 4: Barycentric coordinates</h2>
		Barycentric coordinates are a coordinate system where points are defined within a triangle with 'masses' on the triangles vertices. For certain masses on each vertex of a triangle, a point is defined as the center of mass of that triangle.
		You can use barycentric interpolation to interpolate across a triangle based on the 'weights' on each vertex. The below image demonstrates this by using different colors as 'weights.'
		
		<figure>
			<img src="smooth_triangle.png" alt="color circle" style="width:50%"/>
			<figcaption>This triangle has one red, one green, and one blue vertex. Using barycentric interpolation, the color across the entire triangle is rendered as shown.</figcaption>
		</figure>
		
		<figure>
			<img src="task4-color-circle.png" alt="color circle" style="width:50%"/>
			<figcaption>Color circle rendered using barycentric interpolation.</figcaption>
		</figure>


		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		Pixel sampling is a process used to map a color from a 2D texture to a pixel on a screen when rendering a 3D object. Pixels nearly never line up perfectly with a texture element, so pixel sampling is used to bridge the gap between the two.
		You can do this by just using the color from the nearest texture element, or by interpolating across adjacent elements.

		We used a helper function to determine barycentric coordinates for a sample point, and then got the corresponding texel for that sample point by reading the mipmap with a hardcoded level of 0.
		For the bilinear interpolation, we got the texel values for the four corners of the four nearest pixels of the sample point. We then interpolated from bottom left to top left, a second from bottom right to top right, and then a third between those two. 

			<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="task5-bilinear-1.png" width="400px"/>
				  <figcaption>1 sample / pixel - Basic shapes without sharp edges look decent, however edges are very sharp. One pixel is fully turned on, and the one next to it is completely off. Some pixels in between are even turned off since the triangle does not pass through the center of the pixel creawting a jagged look.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task5-bilinear-16.png" width="400px"/>
				  <figcaption>4 samples / pixel - Already more improved, as gaps between pixels no longer exist (only at the very very corner pixel). Shades of color are introduced, slightly easing edges. Slghtly more pixels have a lower shade of color. This is coming from the pixels whose centers were originally not filled in, but there corners were.  </figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="task5-nearest-1.png" width="400px"/>
				  <figcaption>9 samples / pixel - Visually continuous at sharp corners. Not much of a difference for basic shapes since the same percentage of pixels are being covered no matter the sampling rate (e.g. long edge of yellow triangle will have pixels who are 50% covered, whether sampled at 4, 9 etc.).</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task5-nearest-1.png" width="400px"/>
				  <figcaption>16 samples / pixel - Appears nearly perfect from the larger perspective. Edges of pixel look very soft. Pixel inspector reveals many more pixels have at least some shade compared to no super sampling.  </figcaption>
				</td>
			  </tr>
			</table>
		</div>


		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Level sampling is used to determine what resolution of a texture is to be used during rendering. This is needed to avoid texture aliasing, which occurs when a large texture is mapped to a small pixel area. This causes flickering due to many texture elements being skipped during the search for a sample.
		This can again be done by either choosing the nearest mipmap level to determine the texture resolution, or by interpolating between the two closest levels to smooth things out.-		

		Pixel sampling is fast and doesn't use much memory, but has limited effect in smoothing out textures. Level sampling is a little slower and uses more memory, but is effective in reducing flicker. Increasing sample per pixel is slow and uses lots of memory, but is strong in fixing jagged edges.
		
		Depending on the values of LSM and PSM, we changed how we calculated the mipmap level. When doing a linear interpolation, we would get the barycentric coordinates of the sample point and the two adjacent points (higher x value and higher y value). We would then compute the mipmap level for each of these points and take a weighted average to get the final level to be used on the sample point.-
		We calculated this level using the method described in lecture - we calculated the distance by creating vectors in uv space, and then using the formula given in lecture to determine the level used. 

		Each combination of LSM and PSM called different methods, be that bilinear or nearest, in different combinations. We reused helper functions from past parts to use the different methods for each case.

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="task6-lzero-pnearest.png" width="400px"/>
				  <figcaption>Very jagged corners with little to no blending into the background. Very few pixels are anything except completely dark or completely white, leading to sharp edges and visible jaggies, even when zoomed out.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task6-lzero-plinear.png" width="400px"/>
				  <figcaption>Similarly jagged to using pnearest, but with slightly better smoothing along the edge of the ploygon. There are still visible jaggies in the smoothed out image, but they are not as pronounced as using the nearest neighbor approach.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="task6-lneareset-plinear.png" width="400px"/>
				  <figcaption>Much more smoothing present at the polygon edges, with many pixel values being interpolated between black and white. There are still slight jaggies visible in the full image, though they are more blurred together than when using other approaches.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="task6-lnearest-pnearest.png" width="400px"/>
				  <figcaption>Highest smoothing level of these four configurations. The smoothing moves consistently from full black to full white, and the jaggies in the full zoomed out image are much less pronounced. This approach with a slightly higher sample count would likely eliminate the jaggies alltogether.</figcaption>
				</td>
			  </tr>
			</table>
		</div>
	</body>
</html>